#!/bin/sh
#|-*- mode:lisp -*-|#
#|
exec ros -Q -- $0 "$@"
|#
(progn ;;init forms
  (ros:ensure-asdf)
  #+quicklisp(ql:quickload '(:cl-project) :silent t) ; => (:CL-PROJECT)
  )
;; (cl-project:make-project #p"~/.roswell/local-projects/unio/"
;; 			 :author "biofermin2"
;; 			 :email "supercaveman@gmail.com"
;; 			 :license "MIT"
;; 			 :depends-on '()
;; 			 :description "keyword searcher for S-expression") ; => writing ~/.roswell/local-projects/unio/unio.asd
;; writing ~/.roswell/local-projects/unio/README.org
;; writing ~/.roswell/local-projects/unio/README.markdown
;; writing ~/.roswell/local-projects/unio/.gitignore
;; writing ~/.roswell/local-projects/unio/src/main.lisp
;; writing ~/.roswell/local-projects/unio/tests/main.lisp
;; T
;; (ql:quickload '(:unio) :silent t)	; => (:UNIO)


(defpackage :ros.script.unio.3843091191
  (:use :cl)
  (:export :cat-files :parse-tree :find-str-pos :main)) ; => #<PACKAGE "ROS.SCRIPT.UNIO.3843091191">
(in-package :ros.script.unio.3843091191)     ; => #<PACKAGE "ROS.SCRIPT.UNIO.3843091191">

(defun cat-files (&rest files)
  "複数ファイルを表示"
  (dolist (f files)
    (with-open-file (in f :direction :input)
      (let (buff)
	(loop
	  (if (setq buff (read in nil))
	      (format t "~(~a~)~&" buff)
	      (return)))))))				    ; => CAT-FILES
;;(cat-files "~/clep/src/clep.lisp" "~/howm/junk/while.lisp") ; => NIL
;; (with-output-to-string (*standard-output*)
;;   (cat-files "~/howm/junk/while.lisp"))	; => "(defmacro while (test &rest body) `(do () ((not ,test)) ,@body))"

;; (seek "defmacro" (with-output-to-string (*standard-output*)
;; 		   (cat-files "~/clep/src/clep.lisp"))) ; => 

;; (setf slist
;;       (with-output-to-string (*standard-output*)
;; 	(format t "~s" (cat-files "~/howm/junk/while.lisp")))) ; => "(defmacro while (test &rest body) `(do () ((not ,test)) ,@body))

(defun parse-tree (slist)
  "文字列リストを１文字ずつ解析"
  (loop :for char :across slist
	:with depth = 0
	:when (eq char #\()
	  :do (incf depth)
	:when (eq char #\))
	  :do (decf depth)
	:collect (list char depth)))	; => PARSE-TREE

;; obsolete [2021-10-15 00:09:43]
;; (defun find-str-pos (str slist)
;;   "検索文字列の先頭のpositionをリストで返す"
;;   (loop :for i :across slist
;; 	:count i :into cnt
;; 	:with str-list = (coerce str 'list)
;; 	:when (and (eq (car str-list) i)
;; 		   (equal str (subseq slist (1- cnt) (+ (1- cnt) (length str)))))
;; 	  :collect (1- cnt)))		; => FIND-STR-POS

;; (find-str-pos "a" slist)		; => (7 39)

(defun find-str-pos (str slist)
  "検索文字列の先頭のpositionをリストで返す"
  (let ((str-len (length str)))
    (loop :for i :across slist
	  :when (and (eq i (elt str 0))
	    (equal str (subseq slist cnt (+ cnt str-len))))
	    :collect cnt
	  :count i :into cnt)))		; => FIND-STR-POS

;;(find-str-pos "a" slist)		; => (7 39)

;; Obsolete [2021-10-14 23:16:51]
;; (defun seek (str slist &optional (skin 0))
;;   (let ((top-pos (find-str-pos str slist))
;; 	(parsed-list (parse-tree slist)))
;;     (loop :for i :in top-pos
;; 	  :for first-part = (subseq parsed-list 0 i)
;; 	  :for key-top = (elt parsed-list i)
;; 	  :for key-depth = (- (cadr key-top) skin)
;; 	  :for open-pos = (position `(#\( ,key-depth) (reverse first-part) :test #'equal)
;; 	  :for open-paren = (- i open-pos 1)
;; 	  :for rest-part = (subseq parsed-list i)
;; 	  :for close-pos = (position `(#\) ,(1- key-depth)) rest-part :test #'equal)
;; 	  :for close-paren = (+ i close-pos 1)
;; 	  :do (format t "~s~&" (subseq slist open-paren close-paren))
;; 	  )))				; => SEEK

(defun seek (str slist &optional (skin 0))
  (let ((top-pos (find-str-pos str slist))
	(parsed-list (parse-tree slist)))
    (loop :for i :in top-pos
	  :for first-part = (subseq parsed-list 0 i)
	  :for key-top = (elt parsed-list i)
	  :for key-depth = (- (cadr key-top) skin)
	  :for open-pos = (position `(#\( ,key-depth) first-part :test #'equal :from-end t)
	  :for rest-part = (subseq parsed-list i)
	  :for close-pos = (+ i (position `(#\) ,(1- key-depth)) rest-part :test #'equal) 1)
	  :do (format t "~s~&" (subseq slist open-pos close-pos))
	  )))				; => SEEK

(defmacro main (skey &rest files)
  (declare (ignorable files))
  `(let ((slist (with-output-to-string (*standard-output*)
		  (cat-files ,@files))))
     (seek ,skey slist)))		; => MAIN

(main "defmacro" "~/howm/junk/while.lisp") ; =>
;; The bounding indices 60 and 68 are bad for a sequence of length 64.
;;    [Condition of type SB-KERNEL:BOUNDING-INDICES-BAD-ERROR]
;; See also:
;;   Common Lisp Hyperspec, bounding index designator [:glossary]
;;   Common Lisp Hyperspec, SUBSEQ-OUT-OF-BOUNDS:IS-AN-ERROR [:issue]


;; "(delete-duplicates
;; (mapcar
;;  #'pathname
;;  files)
;; :test
;; #'equal)"
;; "(
;; test
;; &rest
;; body)"
;; "(not
;; ,test)"
;; NIL



;;; vim: set ft=lisp lisp:
;; (defun read-file (file)
;;     (with-open-file (in file :if-does-not-exist nil) 
;;       (with-standard-io-syntax
;; 	(loop (let ((data (read in nil)))
;; 		(if data
;; 		    (format t "\"~(~s~)~%\"" data)
;; 		    (return)))))))	; => READ-FILE

;; ;; ok search関数利用版　作ったけど、遅いから使用せず。
;; (defun search-loop (str slist &optional (n 0))
;;   (let (poslis)
;;     (loop (setq pos (search str slist :start2 n))
;; 	  (if pos
;; 	      (progn (push pos poslis)
;; 		     (setq n (1+ pos)))
;; 	      (return poslis)))))	; => SEARCH-LOOP

;; (setf slist "hogehoobar hoge fuu bar piyopoyopunyo hoge") ; => "hogehoobar hoge fuu bar piyopoyopunyo hoge"
;; (time (find-str-pos "hoge" slist))			  ; => (0 11 38)
;; ;; Evaluation took:
;; ;;   0.000 seconds of real time
;; ;;   0.000006 seconds of total run time (0.000005 user, 0.000001 system)
;; ;;   100.00% CPU
;; ;;   15,059 processor cycles
;; ;;   0 bytes consed
;; (time (search-loop "hoge" slist))	; => (38 11 0)
;; ;; Evaluation took:
;; ;;   0.000 seconds of real time
;; ;;   0.000010 seconds of total run time (0.000009 user, 0.000001 system)
;; ;;   100.00% CPU
;; ;;   33,522 processor cycles
;; ;;   0 bytes consed

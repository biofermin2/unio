#!/bin/sh
#|-*- mode:lisp -*-|#
#|
exec ros -Q -- $0 "$@"
|#
(progn ;;init forms
  (ros:ensure-asdf)
  #+quicklisp(ql:quickload '(:cl-project) :silent t) ; => (:CL-PROJECT)
  )
;; (cl-project:make-project #p"~/.roswell/local-projects/unio/"
;; 			 :author "biofermin2"
;; 			 :email "supercaveman@gmail.com"
;; 			 :license "MIT"
;; 			 :depends-on '()
;; 			 :description "keyword searcher for S-expression") ; => writing ~/.roswell/local-projects/unio/unio.asd
;; writing ~/.roswell/local-projects/unio/README.org
;; writing ~/.roswell/local-projects/unio/README.markdown
;; writing ~/.roswell/local-projects/unio/.gitignore
;; writing ~/.roswell/local-projects/unio/src/main.lisp
;; writing ~/.roswell/local-projects/unio/tests/main.lisp
;; T
;; (ql:quickload '(:unio) :silent t)	; => (:UNIO)


(defpackage :ros.script.unio.3843091191
  (:use :cl)
  (:export :cat-files :parse-tree :find-str-pos :main)) ; => #<PACKAGE "ROS.SCRIPT.UNIO.3843091191">
(in-package :ros.script.unio.3843091191)     ; => #<PACKAGE "ROS.SCRIPT.UNIO.3843091191">

(defun cat-files (&rest files)
  "複数ファイルを表示"
  (dolist (f files)
    (with-open-file
	(in f :direction :input)
      (let (buff)
	(loop
	  (if (setq buff (read in nil))
	      (format t "~(~s~)" buff)
	      (return)))))))		; => CAT-FILES

;; (with-output-to-string (*standard-output*)
;;   (cat-files "~/howm/junk/while.lisp"))	; => "(defmacro while (test &rest body) `(do () ((not ,test)) ,@body))"

;; (seek "defmacro" (with-output-to-string (*standard-output*)
;; 		   (cat-files "~/clep/src/clep.lisp"))) ; => 

;; (setf slist
;;       (with-output-to-string (*standard-output*)
;; 	(format t "~s" (cat-files "~/howm/junk/while.lisp")))) ; => "(defmacro while (test &rest body) `(do () ((not ,test)) ,@body))

(defun parse-tree (slist)
  "文字列リストを１文字ずつ解析"
  (loop :for char :across slist
	:with depth = 0
	:when (eq char #\()
	  :do (incf depth)
	:when (eq char #\))
	  :do (decf depth)
	:collect (list char depth)))	; => PARSE-TREE

(defun find-str-pos (str slist)
  "検索文字列の先頭のpositionをリストで返す"
  (loop :for i :across slist
	:count i :into cnt
	:with str-list = (coerce str 'list)
	:when (and (eq (car str-list) i)
		   (equal str (subseq slist (1- cnt) (+ (1- cnt) (length str)))))
	  :collect (1- cnt)))		; => FIND-STR-POS

(defun seek (str slist &optional (skin 0))
  (let ((top-pos (find-str-pos str slist))
	(parsed-list (parse-tree slist)))
    (loop :for i :in top-pos
	  :for first-part = (subseq parsed-list 1 i)
	  :for key-top = (elt parsed-list i)
	  :for key-depth = (- (cadr key-top) skin)
	  :for open-pos = (position `(#\( ,key-depth) (reverse first-part) :test #'equal)
	  :for open-paren = (- i open-pos 1)
	  :for rest-part = (subseq parsed-list i)
	  :for close-pos = (position `(#\) ,(1- key-depth)) rest-part :test #'equal)
	  :for close-paren = (+ i close-pos 1)
	  :do (format t "~s~&" (subseq slist open-paren close-paren))
	  )))				; => SEEK

(defmacro main (skey &rest files)
  (declare (ignorable files))
  `(let ((slist (with-output-to-string (*standard-output*)
		  (cat-files ,@files))))
     (seek ,skey slist)))		; => MAIN

;; (main "test" "~/clep/src/clep.lisp" "~/howm/junk/while.lisp") ; =>
;; "(delete-duplicates
;; (mapcar
;;  #'pathname
;;  files)
;; :test
;; #'equal)"
;; "(
;; test
;; &rest
;; body)"
;; "(not
;; ,test)"
;; NIL



;;; vim: set ft=lisp lisp:
;; (defun read-file (file)
;;     (with-open-file (in file :if-does-not-exist nil) 
;;       (with-standard-io-syntax
;; 	(loop (let ((data (read in nil)))
;; 		(if data
;; 		    (format t "\"~(~s~)~%\"" data)
;; 		    (return)))))))	; => READ-FILE
